user  www-data;
worker_processes  1;

error_log stderr;

events {
  worker_connections 1024;
  multi_accept on;
}

http {
  include       mime.types;
  default_type  application/octet-stream;

  error_log /var/www/llllll/logs/http_error.log error;
  access_log off;
  keepalive_timeout  65;

  sendfile  on;
  open_file_cache max=1000 inactive=20s;
  open_file_cache_valid 30s;
  open_file_cache_min_uses 5;
  open_file_cache_errors off;

  lua_shared_dict auto_ssl 1m;
  lua_shared_dict auto_ssl_settings 64k;
  resolver 8.8.8.8;

  init_by_lua_block {

    local redis = require "resty.redis"
    local redis_options = { host = "127.0.0.1", port = 6379 , prefix = "ssl" }

    local function get_redis_instance(redis_options)

      local instance = ngx.ctx.auto_ssl_redis_instance

      if instance then
        return instance
      end

      instance = redis:new()

      local ok, err

      if redis_options["socket"] then
        ok, err = instance:connect(redis_options["socket"])
      else
        ok, err = instance:connect(redis_options["host"], redis_options["port"])
      end

      if not ok then
        return false, err
      end

      if redis_options["auth"] then
        ok, err = instance:auth(redis_options["auth"])
        if not ok then
          return false, err
        end
      end

      ngx.ctx.auto_ssl_redis_instance = instance
      return instance
    end

    auto_ssl = (require "resty.auto-ssl").new()

    auto_ssl:set("redis", redis_options)

    auto_ssl:set("storage_adapter", "resty.auto-ssl.storage_adapters.redis")

    auto_ssl:set("allow_domain", function(domain)

      local certstorage = auto_ssl:get("storage")

      local fullchain_pem, privkey_pem = certstorage:get_cert(domain)

      if fullchain_pem then
              return true
      end

      print('yes')

      local redis_instance, instance_err = get_redis_instance(redis_options)
      if instance_err then
        return nil, instance_err
      end


      local res, err = redis_instance:get('domain:' .. domain)

      if res == ngx.null then
        return false
      end

      return true
    end)

    auto_ssl:init()
  }

  init_worker_by_lua_block {
    auto_ssl:init_worker()
  }

  server {
    listen 127.0.0.1:8999;
    client_body_buffer_size 128k;
    client_max_body_size 128k;
    location / {
      content_by_lua_block {
        auto_ssl:hook_server()
      }
    }
  }

  server {
    include /var/www/llllll/nginx.ssl.conf;
    server_name ~(?<subdomain>[^\.]*).llllll.li;
    root /var/www/llllll/sites/$subdomain/public;
  }

  server {
    include /var/www/llllll/nginx.ssl.conf;
    server_name status.blot.im status.llllll.li;
    location / {
      proxy_pass http://localhost:9999;
    }
  }

  server {
    include /var/www/llllll/nginx.ssl.conf;
    server_name mirror.llllll.li bam.llllll.li;
    root /var/www/llllll/sites/mirror/public;
    error_page   403  = @proxy;
    error_page   404  = @proxy;
    try_files $uri index.html $uri/ @proxy;
    location @proxy {
      proxy_pass http://localhost:8888;
    }
  }

  server {
    include /var/www/llllll/nginx.ssl.conf;
    server_name mark-zuckerberg-for-president.com;
    root /var/www/llllll/sites/mark-zuckerberg-for-president;
  }

  server {
    include /var/www/llllll/nginx.ssl.conf;
    server_name fontarchive.org;
    root /var/www/llllll/sites/fontarchive;
  }

  server {
    include /var/www/llllll/nginx.ssl.conf;
    server_name llllll.li;
    root /var/www/llllll/public;

    location ~* /randomcolor {
      return 301 $scheme://randomcolor.llllll.li;
    }

    location ~* /typewriter {
      return 301 $scheme://typewriter.llllll.li;
    }
  }
}
